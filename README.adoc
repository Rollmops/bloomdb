= BloomDB CLI - Database Migration Tool

image:https://github.com/rollmops/bloomdb/workflows/Tests/badge.svg["Build Status", link="https://github.com/rollmops/bloomdb/actions"]
image:https://codecov.io/gh/rollmops/bloomdb/branch/main/graph/badge.svg["Coverage", link="https://codecov.io/gh/rollmops/bloomdb"]

BloomDB is a powerful database migration tool that supports multiple database backends including PostgreSQL, SQLite, and Oracle. It provides versioned and repeatable migrations with proper tracking and error handling.

== Features

* **Multi-database support**: PostgreSQL, SQLite, Oracle
* **Versioned migrations**: Ordered migration execution with version tracking
* **Repeatable migrations**: Re-applyable migrations for triggers, views, etc.
* **Checksum validation**: Flyway-compatible CRC32 checksums detect modified migrations
* **Error handling**: Failed migrations stop execution and aren't recorded
* **Automatic re-execution**: Repeatable migrations automatically re-run when content changes
* **Baseline support**: Initialize existing databases with migration tracking
* **Execution timing**: Track and display migration execution times
* **Version validation**: Ensures migration files follow proper version format

== Quick Start

=== Prerequisites

* Go 1.25 or later
* Database access (PostgreSQL, SQLite, or Oracle)

=== Installation

[source,bash]
----
# Build from source
git clone <repository-url>
cd bloomdb
go build

# Or download pre-built binary (when available)
----

=== Basic Usage

Set the database connection string as an environment variable:

[source,bash]
----
export BLOOMDB_CONNECT_STRING="your_connection_string"
----

. **Initialize migration tracking for existing database:**
+
[source,bash]
----
./bloomdb baseline
----

. **Apply pending migrations:**
+
[source,bash]
----
./bloomdb migrate --path ./migrations
----

. **Check migration status:**
+
[source,bash]
----
./bloomdb info
----

=== Connection Strings

**PostgreSQL:**
[source]
----
postgres://user:password@localhost:5432/database?sslmode=disable
----

**SQLite:**
[source]
----
sqlite:/path/to/database.db
----

**Oracle:**
[source]
----
oracle://user:password@localhost:1521/service_name
----

== Migration Files

=== File Structure

Create a `migrations/` directory with your SQL files:

[source]
----
migrations/
├── V1__Create_users_table.sql
├── V2__Create_posts_table.sql
├── V3__Add_foreign_keys.sql
└── R__Create_updated_at_triggers.sql
----

=== Versioned Migrations

* **Naming**: `V{version}__{description}.sql`
* **Format**: Version must be numeric (e.g., `1`, `1.2`, `1.2.3`)
* **Execution**: Run once in version order
* **Examples**:
** `V1__Create_users_table.sql`
** `V2.1__Add_email_column.sql`
** `V3.0.5__Add_indexes.sql`

=== Repeatable Migrations

* **Naming**: `R__{description}.sql`
* **Execution**: Re-run when content changes (different checksum)
* **Use cases**: Triggers, views, functions, stored procedures
* **Examples**:
** `R__Create_user_triggers.sql`
** `R__Update_product_views.sql`
** `R__Refresh_materialized_views.sql`

=== Database-Specific Migrations (Filtering)

BloomDB supports filtering migrations by database type, allowing you to maintain database-specific versions of migrations alongside common ones.

==== Filter Modes

* **No filter** (default): Only load migrations without filter suffixes
* **Hard filter** (`BLOOMDB_FILTER_HARD`): Only load migrations matching the specified filter
* **Soft filter** (`BLOOMDB_FILTER_SOFT`): Prefer filtered migrations, fall back to non-filtered versions

==== Version Identification

BloomDB identifies migrations differently based on their type:

* **Versioned migrations** are identified by version number only (not description):
** `V1.0__generic.sql` and `V1.0__postgres_specific.postgres.sql` are treated as the same version (1.0)
** Different descriptions are allowed for database-specific implementations of the same version
** In the database, only the version number matters for tracking versioned migrations
* **Repeatable migrations** are identified by description:
** `R__views.sql` and `R__views_postgres.postgres.sql` are treated as different migrations
** Must have the same description to be considered the same repeatable migration

==== File Naming

Add an optional filter suffix before the `.sql` extension:

[source]
----
# Versioned migrations
V1__Create_users_table.sql           # Common version (no filter)
V1__Create_users_table.postgres.sql  # PostgreSQL-specific version
V1__Create_users_table.oracle.sql    # Oracle-specific version

# Repeatable migrations
R__Create_triggers.sql               # Common version
R__Create_triggers.mysql.sql         # MySQL-specific version
----

==== Usage Examples

**Hard Filter Mode** (only use filtered migrations):
[source,bash]
----
# Apply only PostgreSQL-specific migrations
export BLOOMDB_FILTER_HARD="postgres"
./bloomdb migrate --path ./migrations

# This will load:
# - V1__Create_users_table.postgres.sql (if it exists)
# - Skip: V1__Create_users_table.sql (no filter)
# - Skip: V1__Create_users_table.oracle.sql (different filter)
----

**Soft Filter Mode** (prefer filtered, fall back to common):
[source,bash]
----
# Prefer Oracle-specific, use common as fallback
export BLOOMDB_FILTER_SOFT="oracle"
./bloomdb migrate --path ./migrations

# For V1__Create_users_table:
# - Use V1__Create_users_table.oracle.sql if it exists
# - Otherwise fall back to V1__Create_users_table.sql
# - Skip: V1__Create_users_table.postgres.sql (different filter)
----

**No Filter Mode** (default behavior):
[source,bash]
----
# Only use common migrations (no filter variable set)
./bloomdb migrate --path ./migrations

# This will load:
# - V1__Create_users_table.sql
# - Skip: V1__Create_users_table.postgres.sql (has filter)
# - Skip: V1__Create_users_table.oracle.sql (has filter)
----

==== Filter Priority

When both environment variables are set, `BLOOMDB_FILTER_HARD` takes precedence over `BLOOMDB_FILTER_SOFT`.

==== Use Cases

* **Multi-database support**: Maintain a single migration directory for multiple database types
* **Database-specific syntax**: Use native features while keeping common migrations portable
* **Environment-specific migrations**: Different behavior for dev/staging/prod
* **Gradual migration**: Soft filter mode enables smooth transitions when adding database-specific optimizations

== Commands

=== baseline

Initialize migration tracking for existing databases:

[source,bash]
----
./bloomdb baseline [flags]

Flags:
  --baseline-version string  Baseline version to use (default: "1")
  --path string              Directory containing migration files (default: ".")
  --table-name string        Migration table name (default: "BLOOMDB_VERSION")

Environment Variables:
  BLOOMDB_CONNECT_STRING      Database connection string (required)
  BLOOMDB_BASELINE_VERSION    Default baseline version (overridden by --baseline-version flag)
----

**Baseline Version Priority:**

BloomDB determines the baseline version using the following priority order (highest to lowest):

1. **Existing database baseline** - If a baseline record already exists in the database, that version is always used. This prevents accidental baseline version changes and ensures consistency.
2. **CLI flag** (`--baseline-version`) - Explicitly specified version on command line
3. **Environment variable** (`BLOOMDB_BASELINE_VERSION`) - Version set in environment
4. **Default value** - Version "1" if nothing else is specified

When an existing baseline is found, the command will display a success message showing the existing version, even if you requested a different version.

**Examples:**

[source,bash]
----
# Use default baseline version (1)
./bloomdb baseline

# Specify baseline version via CLI flag
./bloomdb baseline --baseline-version 2.5

# Use environment variable
export BLOOMDB_BASELINE_VERSION="3.0"
./bloomdb baseline

# If baseline already exists, the existing version takes priority
./bloomdb baseline --baseline-version 5.0  # Will use existing version from DB instead
----

=== migrate

Apply pending migrations:

[source,bash]
----
./bloomdb migrate [flags]

Flags:
  --path string          Directory containing migration files (default: ".")
  --table-name string    Migration table name (default: "BLOOMDB_VERSION")
  --post-migration-script string   Path to post-migration SQL script (env: BLOOMDB_POST_MIGRATION_SCRIPT)

Environment Variables:
  BLOOMDB_CONNECT_STRING  Database connection string
----

=== info

Display migration status and database information:

[source,bash]
----
./bloomdb info [flags]

Flags:
  --path string          Directory containing migration files (default: ".")
  --table-name string    Migration table name (default: "BLOOMDB_VERSION")

Environment Variables:
  BLOOMDB_CONNECT_STRING  Database connection string
----

=== repair

Repair migration records (for manual recovery):

[source,bash]
----
./bloomdb repair [flags]

Flags:
  --table-name string    Migration table name (default: "BLOOMDB_VERSION")
----

=== destroy

Remove all database objects (use with caution):

[source,bash]
----
./bloomdb destroy [flags]

Flags:
  --table-name string    Migration table name (default: "BLOOMDB_VERSION")
----

== Environment Variables

You can use environment variables instead of command-line flags:

[source,bash]
----
export BLOOMDB_CONNECT_STRING="postgres://user:pass@localhost/db"
export BLOOMDB_PATH="./migrations"
export BLOOMDB_VERSION_TABLE_NAME="my_migrations"
export BLOOMDB_BASELINE_VERSION="2"

# Filter variables for database-specific migrations
export BLOOMDB_FILTER_HARD="postgres"    # Only use postgres-filtered migrations
export BLOOMDB_FILTER_SOFT="oracle"      # Prefer oracle-filtered, fall back to common

./bloomdb migrate  # No need to specify connection string or path
----

**Available Environment Variables:**

[cols="2*"]
|===
| Variable | Description

| `BLOOMDB_CONNECT_STRING` | Database connection string (required)
| `BLOOMDB_PATH` | Directory containing migration files
| `BLOOMDB_VERSION_TABLE_NAME` | Migration table name
| `BLOOMDB_BASELINE_VERSION` | Default baseline version
| `BLOOMDB_FILTER_HARD` | Only load migrations with this filter (strict mode)
| `BLOOMDB_FILTER_SOFT` | Prefer filtered migrations, fall back to non-filtered (compatibility mode)
| `BLOOMDB_POST_MIGRATION_SCRIPT` | Path to post-migration SQL script
| `BLOOMDB_VERBOSE` | Enable verbose/debug output
| `BLOOMDB_PRINTER` | Output format: `human`, `test`, or `json`
|===

== Migration Process

=== What Happens During Migration

. **Version Validation**: Checks that all versioned migrations have valid format
. **Database Connection**: Connects to the specified database
. **Table Check**: Ensures migration table exists
. **Version Comparison**: Compares file versions with database records
. **Execution**: Runs pending migrations in order
. **Recording**: Stores migration records with execution time and status
. **Error Handling**: Stops on first failure with detailed error message

=== Migration Status Types

* **success**: Migration completed successfully
* **pending**: Migration not yet applied
* **failed**: Migration failed during execution
* **checksum**: Migration file was modified after being applied (checksum mismatch)
* **baseline**: Migration was baselined (skipped)
* **below baseline**: Migration version is below baseline version

== Checksum Validation

BloomDB automatically validates migration file integrity using Flyway-compatible CRC32 checksums. This feature helps detect accidental or unauthorized modifications to applied migrations.

=== How It Works

. **Checksum calculation**: When a migration is applied, BloomDB calculates a CRC32 checksum of the file content
. **Storage**: The checksum is stored in the migration table alongside the migration record
. **Validation on info**: When you run `info`, BloomDB recalculates checksums and compares them
. **Validation on migrate**: Before applying new migrations, the `migrate` command validates all applied migrations
. **Detection**: If a migration file's checksum doesn't match the stored value, it's flagged with "⚠ checksum" status
. **Migration blocking**: The `migrate` command will refuse to proceed if any checksum mismatches are detected

=== Features

* **Flyway-compatible**: Uses the same CRC32 algorithm as Flyway for cross-platform compatibility
* **Line-ending normalization**: Different line endings (\n, \r\n, \r) produce the same checksum
* **UTF-8 BOM handling**: Automatically strips UTF-8 Byte Order Mark from files
* **Cross-platform**: Produces consistent checksums regardless of operating system

=== Example

[source,bash]
----
# Apply migrations (checksums are calculated and stored)
./bloomdb migrate

# View migration status
./bloomdb info

# If you modify an applied migration file
echo "-- Modified" >> V1__Create_users_table.sql

# The checksum mismatch is detected by info command
./bloomdb info
# Output shows: V1 | Create users table | ⚠ checksum

# Attempting to run migrate is blocked
./bloomdb migrate
# Output shows:
# ✗ Checksum validation failed for 1 migration(s):
# ✗   - V1 - Create_users_table (expected: 1234567890, found: 9876543210)
# ⚠ Migration files have been modified after being applied.
# ⚠ Please run the repair command to update checksums, or restore the original files.

# Fix the issue by restoring the original file or running repair
./bloomdb repair  # Updates checksums to match current files
./bloomdb migrate # Now migrations can proceed
----

=== Best Practices

* **Don't modify applied migrations**: Once a migration is applied, treat it as immutable
* **Create new migrations**: Instead of editing old migrations, create new ones to make changes
* **Use version control**: Track all migration files in Git to maintain history
* **Investigate mismatches**: If you see a checksum warning, investigate whether it was intentional

== Examples

=== Complete Workflow

[source,bash]
----
# Set connection string
export BLOOMDB_CONNECT_STRING="postgres://user:pass@localhost/mydb"

# 1. Initialize existing database
./bloomdb baseline

# 2. Apply migrations
./bloomdb migrate --path ./migrations

# 3. Check status
./bloomdb info --path ./migrations
----

=== Using Environment Variables

[source,bash]
----
# Set up environment
export BLOOMDB_CONNECT_STRING="sqlite:///app/data.db"
export BLOOMDB_PATH="./database/migrations"

# Run commands without connection string
./bloomdb migrate
./bloomdb info
----

=== Custom Migration Table

[source,bash]
----
# Use custom table name
./bloomdb migrate --table-name "app_migrations"

# Or via environment
export BLOOMDB_VERSION_TABLE_NAME="app_migrations"
./bloomdb migrate
----

== Error Handling

=== Migration Failures

When a migration fails:

. **Execution stops**: No further migrations are executed
. **Error recorded**: Failed migration is recorded with error details
. **Detailed output**: Clear error message with step information
. **Recovery possible**: Fix the issue and re-run to continue

=== Common Issues

**Invalid version format:**
[source]
----
Error: invalid version format in file Vabc__migration.sql: abc (expected format: 1, 1.2, 1.2.3, etc.)
----

**Migration table not found:**
[source]
----
Error: Table 'BLOOMDB_VERSION' does not exist
Solution: Run baseline command first
----

**SQL syntax error:**
[source]
----
Error: Migration V1__Create_table.sql failed: syntax error at line 5
Solution: Fix SQL syntax and re-run
----

== Best Practices

=== Migration Files

. **Use descriptive names**: `V1__Create_users_table.sql` instead of `V1__table.sql`
. **Keep migrations small**: One logical change per migration
. **Test migrations**: Verify SQL syntax and logic
. **Use transactions**: Wrap related statements in transactions
. **Handle rollbacks**: Consider rollback scenarios

=== Database Design

. **Idempotent operations**: Design migrations to be re-runnable where possible
. **Backward compatibility**: Consider impact on existing applications
. **Performance**: Use appropriate indexes and batch operations
. **Data integrity**: Include proper constraints and validations

=== Version Management

. **Semantic versioning**: Use consistent version numbering
. **Sequential versions**: Don't skip version numbers
. **Branch management**: Handle migration conflicts in feature branches

== Post-Migration Scripts

BloomDB supports post-migration SQL scripts that execute after all migrations complete successfully. These scripts support Go templating and have access to migration metadata including created and deleted database objects.

=== Basic Usage

Post-migration scripts are only executed when explicitly specified using the CLI flag or environment variable. The system does not automatically look for post-migration scripts in your migration directory.

=== Specifying Post-Migration Scripts

You must specify a post-migration script path using CLI flag or environment variable:

[source,bash]
----
# Using CLI flag
./bloomdb migrate --post-migration-script ./custom/post.sql

# Using environment variable
export BLOOMDB_POST_MIGRATION_SCRIPT="./custom/post.sql"
./bloomdb migrate

# Relative path (resolved from migration directory)
./bloomdb migrate --post-migration-script ../shared/post_migration.sql
----

=== Template Variables

Post-migration scripts have access to the following variables in your Go templates:

[cols="2*"]
|===
| Variable | Type & Description
| `.CreatedObjects` | `[]DatabaseObject` - List of database objects created during migration
| `.DeletedObjects` | `[]DatabaseObject` - List of database objects deleted during migration
| `.MigrationPath` | `string` - Path to the migration directory
| `.DatabaseType` | `string` - Database type (sqlite, postgresql, oracle)
| `.TableName` | `string` - Name of the migration table
|===

Each `DatabaseObject` contains:
* `.Type` - Object type (table, view, index, etc.)
* `.Name` - Object name

=== Example Post-Migration Script

Here's a comprehensive example that demonstrates all available features:

[source,sql]
----
-- Post-migration script with Go templating (PostgreSQL compatible)
-- This script executes after all migrations are completed successfully

{{- if .CreatedObjects}}
-- Log all created objects
DO $$
BEGIN
    RAISE NOTICE 'Migration completed successfully!';
    RAISE NOTICE 'Created {{len .CreatedObjects}} database objects:';
    {{- range .CreatedObjects}}
    RAISE NOTICE '  - {{.Type}}: {{.Name}}';
    {{- end}}
END $$;

{{- if .DeletedObjects}}
-- Log all deleted objects
DO $$
BEGIN
    RAISE NOTICE 'Deleted {{len .DeletedObjects}} database objects:';
    {{- range .DeletedObjects}}
    RAISE NOTICE '  - {{.Type}}: {{.Name}}';
    {{- end}}
END $$;
{{- end}}

-- Create a summary table with migration information
CREATE TABLE IF NOT EXISTS migration_summary (
    id SERIAL PRIMARY KEY,
    migration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    database_type VARCHAR(50) NOT NULL,
    total_objects INTEGER NOT NULL,
    notes TEXT
);

-- Insert summary record
INSERT INTO migration_summary (database_type, total_objects, notes)
VALUES (
    '{{.DatabaseType}}',
    {{len .CreatedObjects}},
    'Migration completed. Created objects: {{range .CreatedObjects}}{{.Type}}:{{.Name}} {{end}}{{if .DeletedObjects}}Deleted objects: {{range .DeletedObjects}}{{.Type}}:{{.Name}} {{end}}{{end}}'
);

{{- else if .DeletedObjects}}
-- Only objects were deleted during migration
DO $$
BEGIN
    RAISE NOTICE 'Migration completed but objects were deleted';
    RAISE NOTICE 'Deleted {{len .DeletedObjects}} database objects:';
    {{- range .DeletedObjects}}
    RAISE NOTICE '  - {{.Type}}: {{.Name}}';
    {{- end}}
END $$;

INSERT INTO migration_summary (database_type, total_objects, notes)
VALUES (
    '{{.DatabaseType}}',
    0,
    'Migration completed. Deleted objects: {{range .DeletedObjects}}{{.Type}}:{{.Name}} {{end}}'
);

{{- else}}
-- No objects were created or deleted during migration
DO $$
BEGIN
    RAISE NOTICE 'Migration completed but no database objects were changed';
END $$;

INSERT INTO migration_summary (database_type, total_objects, notes)
VALUES (
    '{{.DatabaseType}}',
    0,
    'Migration completed but no database objects were changed'
);
{{- end}}
----

=== Template Syntax Examples

**Conditional logic:**
[source,sql]
----
{{- if .CreatedObjects}}
-- Objects were created
SELECT '{{len .CreatedObjects}} objects created';
{{- end}}

{{- if and .CreatedObjects .DeletedObjects}}
-- Both creation and deletion occurred
SELECT 'Schema changes detected';
{{- end}}
----

**Looping through objects:**
[source,sql]
----
{{- range .CreatedObjects}}
-- Process each created object
{{- if eq .Type "table"}}
-- Handle table creation: {{.Name}}
{{- else if eq .Type "index"}}
-- Handle index creation: {{.Name}}
{{- end}}
{{- end}}
----

**Database-specific logic:**
[source,sql]
----
{{- if eq .DatabaseType "postgresql"}}
-- PostgreSQL-specific code
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
{{- else if eq .DatabaseType "sqlite"}}
-- SQLite-specific code
PRAGMA foreign_keys = ON;
{{- end}}
----

=== Use Cases

Post-migration scripts are perfect for:

. **Documentation**: Auto-generate documentation for created objects
. **Notifications**: Send alerts about schema changes
. **Audit logging**: Record all changes in audit tables
. **Data seeding**: Populate reference data after schema creation
. **Performance optimization**: Create indexes after data loading
. **Integration**: Trigger external processes or API calls
. **Reporting**: Generate migration summary reports

=== Best Practices

. **Keep scripts idempotent**: Design scripts to run multiple times safely
. **Use conditional logic**: Handle cases where no objects are created/deleted
. **Database compatibility**: Use `{{.DatabaseType}}` for database-specific code
. **Error handling**: Wrap operations in proper error handling
. **Testing**: Test templates with different migration scenarios
. **Documentation**: Document what your post-migration scripts do

=== Error Handling

If a post-migration script fails:
* The error is logged but doesn't rollback successful migrations
* A warning message is displayed
* The migration process is still considered successful
* Fix the script and re-run to execute it properly

== Advanced Usage

=== Multiple Environments

[source,bash]
----
# Development
export BLOOMDB_CONNECT_STRING="$DEV_DB"
./bloomdb migrate --path ./migrations/dev

# Staging
export BLOOMDB_CONNECT_STRING="$STAGING_DB"
./bloomdb migrate --path ./migrations/staging

# Production
export BLOOMDB_CONNECT_STRING="$PROD_DB"
./bloomdb migrate --path ./migrations/prod
----

=== Custom Configuration

[source,bash]
----
# Custom baseline version for existing database
export BLOOMDB_BASELINE_VERSION="5.2"
./bloomdb baseline

# Custom migration directory
./bloomdb migrate --path ./sql/migrations

# Custom table name
./bloomdb migrate --table-name "schema_migrations"
----

== Troubleshooting

=== Getting Help

[source,bash]
----
# Show command help
./bloomdb --help
./bloomdb migrate --help

# Enable debug logging
./bloomdb migrate --log-level debug
----

=== Common Problems

**Connection issues:**
* Verify connection string format
* Check database server is running
* Ensure network connectivity
* Validate credentials and permissions

**Migration issues:**
* Check SQL syntax in migration files
* Verify file naming conventions
* Ensure proper file permissions
* Review error messages for specific issues

**Performance issues:**
* Use appropriate indexes
* Batch large data operations
* Consider database-specific optimizations
* Monitor execution times

== Integration Tests

BloomDB includes comprehensive integration tests for all supported database systems. These tests verify that all functionality works correctly across different database platforms.

=== Available Tests

* **SQLite**: Fast, file-based tests (no external dependencies)
* **PostgreSQL**: Containerized tests using PostgreSQL 15
* **Oracle**: Enterprise-grade tests using Oracle Database Free

=== Running Tests

All integration tests are located in the `integration-tests/` directory:

[source,bash]
----
# SQLite tests (fastest)
cd integration-tests
./integration-test-sqlite.sh

# PostgreSQL tests (medium speed)
cd integration-tests  
./run-postgresql-tests.sh

# Oracle tests (slowest, most comprehensive)
cd integration-tests
./run-oracle-tests.sh
----

=== Test Coverage

The integration tests verify:

* **Baseline functionality** - Below-baseline migration detection
* **Migration execution** - Successful migration runs
* **Failed migration handling** - Error detection and recovery
* **Repair functionality** - Failed migration cleanup
* **Checksum validation** - Modified migration file detection
* **Missing file detection** - Deleted migration file handling
* **Repeatable migrations** - Repeatable migration updates
* **Database cleanup** - Destroy functionality

=== Custom Baseline Version

All test scripts accept an optional baseline version parameter:

[source,bash]
----
# Uses default baseline version (0.5)
./integration-test-sqlite.sh

# Uses custom baseline version (1.2)
./integration-test-sqlite.sh 1.2
----

For detailed setup instructions and troubleshooting, see `integration-tests/README.md`.

== License

[Add your license information here]